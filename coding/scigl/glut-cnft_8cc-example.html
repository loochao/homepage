<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title></title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="header">
<ul class="simple">
<li><a class="reference" href="index.html">Home</a></li>
<li><a class="reference" href="download.html">Download</a></li>
<li><a class="reference" href="documentation.html">Documentation</a></li>
<li><a class="reference" href="myexamples.html">Examples</a></li>
<li><a class="reference" href="screenshots.html">Screenshots</a></li>
</ul>
<hr class="header"/>
<div class="info">Last generated on 27 Nov 2008 using Doxygen v. 1.5.7.1</div>
</div>
<!-- Generated by Doxygen 1.5.7.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="contents">
<h1>glut-cnft.cc</h1><div align="center">
<img src="glut-cnft-600x400.png" alt="glut-cnft-600x400.png">
</div>
<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (C) 2008 Nicolas P. Rougier</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software: you can redistribute it and/or modify it under</span>
<span class="comment"> * the terms of the GNU General Public License as published by the Free Software</span>
<span class="comment"> * Foundation, either version 3 of the License, or (at your option) any later</span>
<span class="comment"> * version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="comment"> * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</span>
<span class="comment"></span>
<span class="comment"> * You should have received a copy of the GNU General Public License along with</span>
<span class="comment"> * this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="comment"> */</span>
<span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="preprocessor">#include "object.h"</span> 
<span class="preprocessor">#if defined(__APPLE__)</span>
<span class="preprocessor"></span><span class="preprocessor">    #include &lt;Glut/glut.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">    #include &lt;GL/glut.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include "scene.h"</span> 
<span class="preprocessor">#include "colorbar.h"</span> 
<span class="preprocessor">#include "surface.h"</span>
<span class="preprocessor">#include "textbox.h"</span>

<span class="keyword">struct </span>Network {
    <span class="keywordtype">int</span>   size;
    <span class="keywordtype">double</span> *units;
    <span class="keywordtype">double</span> *afferents;
    <span class="keywordtype">double</span> *laterals_p;
    <span class="keywordtype">double</span> *laterals_m;
    <span class="keywordtype">double</span> af_i;            <span class="comment">// afferent default input weight (afferents)</span>
    <span class="keywordtype">double</span> gp_w, gp_i;  <span class="comment">// Parameter for positive gaussian (laterals)</span>
    <span class="keywordtype">double</span> gm_w, gm_i;  <span class="comment">// Paremeter for negative gaussian (laterals)</span>
    <span class="keywordtype">double</span> alpha;
    <span class="keywordtype">double</span> dt;
    <span class="keywordtype">double</span> baseline;
    <span class="keywordtype">int</span> seed;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> epochs;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> age;
    <span class="keywordtype">double</span> bubble_x, bubble_y;
    <span class="keywordtype">double</span> sum_dist;
    <span class="keywordtype">double</span> sum_dist2;
};

<span class="keyword">struct </span>Stimulus {
    <span class="keywordtype">double</span> x, y;
    <span class="keywordtype">double</span> dx, dy;
    <span class="keywordtype">double</span> dx_, dy_;
};
<span class="keyword">struct </span>Environment {
    <span class="keywordtype">int</span> size;
    <span class="keywordtype">double</span> *units;
    <span class="keywordtype">double</span> noise_level;
    <span class="keywordtype">int</span>   stim_n;
    <span class="keywordtype">double</span> stim_w, stim_s;
    Stimulus *stims;
    <span class="keywordtype">int</span> refresh_rate;
};  
Environment env;
Network net;


ScenePtr scene = ScenePtr (<span class="keyword">new</span> <a name="_a0"></a><a class="code" href="classScene.html" title="Container for objects and widgets.">Scene</a>);
ColorbarPtr colorbar = ColorbarPtr (<span class="keyword">new</span> <a name="_a1"></a><a class="code" href="classColorbar.html" title="Representation of a colormap.">Colorbar</a>);
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> button = 0;
<span class="keyword">static</span> <a name="_a2"></a><a class="code" href="classVec4f.html" title="Vector of 4 floats.">Size</a> window_size;
<span class="keyword">static</span> <a class="code" href="classVec4f.html" title="Vector of 4 floats.">Position</a> window_position;
<span class="keyword">static</span> <span class="keywordtype">bool</span> fullscreen = <span class="keyword">false</span>;

<span class="keywordtype">void</span> switch_fullscreen (<span class="keywordtype">void</span>) {
    <span class="keywordflow">if</span> (fullscreen) {
        <span class="keywordflow">if</span> (not window_size.<a name="a3"></a><a class="code" href="classVec4f.html#7ee69963d287646ca533da53aaeedcf2">width</a>)
            window_size = <a class="code" href="classVec4f.html" title="Vector of 4 floats.">Size</a> (1000,800);
        glutReshapeWindow (<span class="keywordtype">int</span>(window_size.<a class="code" href="classVec4f.html#7ee69963d287646ca533da53aaeedcf2">width</a>), <span class="keywordtype">int</span>(window_size.<a name="a4"></a><a class="code" href="classVec4f.html#aff2e23b42e6ae4ab7145936c32617a9">height</a>));
        glutPositionWindow (<span class="keywordtype">int</span>(window_position.<a name="a5"></a><a class="code" href="classVec4f.html#b1956fd0918f9ecc5e47420874b17ec2">x</a>), <span class="keywordtype">int</span>(window_position.<a name="a6"></a><a class="code" href="classVec4f.html#c4da05332b2ed24a3b6eefe231278b58">y</a>));
        fullscreen = <span class="keyword">false</span>;
    } <span class="keywordflow">else</span> {
        window_position = <a class="code" href="classVec4f.html" title="Vector of 4 floats.">Position</a> (glutGet(GLUT_WINDOW_X), glutGet(GLUT_WINDOW_Y));
        window_size = <a class="code" href="classVec4f.html" title="Vector of 4 floats.">Size</a> (glutGet(GLUT_WINDOW_WIDTH), glutGet(GLUT_WINDOW_HEIGHT));
        glutFullScreen();
        fullscreen = <span class="keyword">true</span>;
    }
}

<span class="keywordtype">void</span> on_key_press (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {

    <span class="keywordflow">if</span> (key == <span class="charliteral">' '</span>) {
        memset (net.units, 0, net.size*net.size*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
        <span class="keywordflow">return</span>;
    }

    scene-&gt;key_press (key);
}

<span class="keywordtype">void</span> on_special_key_press (<span class="keywordtype">int</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> k = 0;
    <span class="keywordflow">switch</span> (key) {
    <span class="keywordflow">case</span> GLUT_KEY_F1:
        switch_fullscreen();
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_KEY_F2:
        <span class="keywordflow">if</span> (colorbar-&gt;get_visible()) colorbar-&gt;hide (250);
        <span class="keywordflow">else</span>                         colorbar-&gt;show (250);        
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_KEY_UP:    <span class="comment">// Control-i</span>
        k = <span class="charliteral">'i'</span>-<span class="charliteral">'a'</span> + 1;        
        env.noise_level += 0.05f;
        <span class="keywordflow">if</span> (env.noise_level &gt; 1.0f)
            env.noise_level = 1.0f;
        <span class="keywordflow">return</span>;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_KEY_DOWN:  <span class="comment">// Control-j</span>
        k = <span class="charliteral">'j'</span>-<span class="charliteral">'a'</span> + 1;
        env.noise_level -= 0.05f;
        <span class="keywordflow">if</span> (env.noise_level &lt; 0.0f)
            env.noise_level = 0.0f;
        <span class="keywordflow">return</span>;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_KEY_LEFT:  <span class="comment">// Control-b</span>
        k = <span class="charliteral">'b'</span>-<span class="charliteral">'a'</span> + 1;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_KEY_RIGHT: <span class="comment">// Control-f</span>
        k = <span class="charliteral">'f'</span>-<span class="charliteral">'a'</span> + 1;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_KEY_HOME:  <span class="comment">// Control-a</span>
        k = <span class="charliteral">'a'</span>-<span class="charliteral">'a'</span> + 1;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_KEY_END:   <span class="comment">// Control-e</span>
        k = <span class="charliteral">'e'</span>-<span class="charliteral">'a'</span> + 1;
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        k = 0;
        <span class="keywordflow">break</span>;
    }
    scene-&gt;key_press (k);
}

<span class="keywordtype">void</span> on_mouse_button (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> state, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {
    <span class="keywordflow">switch</span> (b) {
    <span class="keywordflow">case</span> GLUT_LEFT_BUTTON:   button = 1;  <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_MIDDLE_BUTTON: button = 2;  <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_RIGHT_BUTTON:  button = 3;  <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:                 button = 0;  <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">switch</span> (state) {
    <span class="keywordflow">case</span> GLUT_UP:
        scene-&gt;button_release (button, x, y);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> GLUT_DOWN:
        scene-&gt;button_press (button, x, y);
        <span class="keywordflow">break</span>;
    }
}

<span class="keywordtype">void</span> on_mouse_move (<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {
    scene-&gt;mouse_motion (button, x, y);
}

<span class="keywordtype">void</span> display (<span class="keywordtype">void</span>) {
    glClearColor (1,1,1,1);
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    scene-&gt;render();
    glutSwapBuffers();
}

<span class="keywordtype">void</span> reshape (<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height) {
    glViewport (0,0,width, height);
    glutPostRedisplay();
 }

<span class="keywordtype">double</span> gaussian (<span class="keywordtype">double</span> center_x, <span class="keywordtype">double</span> A, <span class="keywordtype">double</span> x)
{
    <span class="keywordflow">return</span> exp (-((center_x-x)*(center_x-x)/(A*A)));
 }

<span class="keywordtype">double</span> gaussian (<span class="keywordtype">double</span> center_x, <span class="keywordtype">double</span> center_y, <span class="keywordtype">double</span> A, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y)
{
    <span class="keywordflow">return</span> exp (-((center_x-x)*(center_x-x)/(A*A) + (center_y-y)*(center_y-y)/(A*A)));
 }

<span class="keywordtype">void</span> update (Environment *env)
{
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; (env-&gt;size*env-&gt;size); i++)
        env-&gt;units[i] = 0;
    
    for (<span class="keywordtype">int</span> k=0; k&lt;env-&gt;stim_n; k++) {
        <span class="keywordtype">double</span> center_x = env-&gt;stims[k].x * env-&gt;size;
        <span class="keywordtype">double</span> center_y = env-&gt;stims[k].y * env-&gt;size;
        <span class="keywordtype">double</span> size     = env-&gt;stim_w * env-&gt;size/2.0f;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = <span class="keywordtype">int</span>(center_y-3*size); j &lt; int(center_y+3*size); j++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <span class="keywordtype">int</span>(center_x-3*size); i &lt; int(center_x+3*size); i++) {
                <span class="keywordflow">if</span> ((j&gt;=0) &amp;&amp; (i&gt;=0) &amp;&amp; (j&lt;env-&gt;size) &amp;&amp; (i&lt;env-&gt;size)) {
                    env-&gt;units[j*env-&gt;size+i] += gaussian (center_x, center_y, size, i, j);
                }
            }
        }
    }
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; (env-&gt;size*env-&gt;size); i++) {
        env-&gt;units[i] += (2*(random()/double(RAND_MAX))-1)*env-&gt;noise_level;
        <span class="keywordflow">if</span> (env-&gt;units[i] &gt; 1)
            env-&gt;units[i] = 1;
    }
    
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;env-&gt;stim_n; i++) {
        env-&gt;stims[i].x += env-&gt;stims[i].dx+env-&gt;stims[i].dx_;
        env-&gt;stims[i].y += env-&gt;stims[i].dy+env-&gt;stims[i].dy_;
        <span class="keywordflow">if</span> (env-&gt;stims[i].x &lt; env-&gt;stim_w) {
            env-&gt;stims[i].x = env-&gt;stim_w;
            env-&gt;stims[i].dx *= -1;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (env-&gt;stims[i].x &gt; (1.0f-env-&gt;stim_w)) {
            env-&gt;stims[i].x = 1-env-&gt;stim_w;
            env-&gt;stims[i].dx *= -1;
        }
        <span class="keywordflow">if</span> (env-&gt;stims[i].y &lt; env-&gt;stim_w) {
            env-&gt;stims[i].y = env-&gt;stim_w;
            env-&gt;stims[i].dy *= -1;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (env-&gt;stims[i].y &gt; (1-env-&gt;stim_w)) {
            env-&gt;stims[i].y = 1-env-&gt;stim_w;
            env-&gt;stims[i].dy *= -1;
        }
    }

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;env-&gt;stim_n; i++) {
        env-&gt;stims[i].dx_ = 0;
        env-&gt;stims[i].dy_ = 0;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;env-&gt;stim_n; j++) {
            <span class="keywordflow">if</span> (i != j) {
                <span class="keywordtype">double</span> dx = (env-&gt;stims[i].x - env-&gt;stims[j].x)/(3.0*env-&gt;stim_w);
                <span class="keywordtype">double</span> dy = (env-&gt;stims[i].y - env-&gt;stims[j].y)/(3.0*env-&gt;stim_w);
                <span class="keywordtype">double</span> d = dx*dx+dy*dy;
                <span class="keywordflow">if</span> (d &gt; 0) {
                    d = sqrt(d);
                    <span class="comment">//                    double r = 0.0005/(d*d*d*d);</span>
                    <span class="keywordtype">double</span> r = 0.00005/(d*d*d*d);
                    env-&gt;stims[i].dx_ += r*dx;
                    env-&gt;stims[i].dy_ += r*dy;
                }
            }
        }
    }
}

<span class="keywordtype">void</span> update (Network *net)
{
    <span class="keyword">static</span> <span class="keywordtype">double</span> *buffer  = 0;
    <span class="keyword">static</span> <span class="keywordtype">double</span> *buffer1 = 0;
    <span class="keyword">static</span> <span class="keywordtype">double</span> *buffer2 = 0;
    <span class="keywordflow">if</span> (buffer == 0) {
        buffer  = <span class="keyword">new</span> <span class="keywordtype">double</span> [net-&gt;size*net-&gt;size];
        buffer1 = <span class="keyword">new</span> <span class="keywordtype">double</span> [net-&gt;size*net-&gt;size];
         buffer2 = <span class="keyword">new</span> <span class="keywordtype">double</span> [net-&gt;size*net-&gt;size];
    }
    
    memset (buffer, 0, net-&gt;size*net-&gt;size*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
    memset (buffer1, 0, net-&gt;size*net-&gt;size*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;net-&gt;size; y++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;net-&gt;size; x++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;net-&gt;size; i++) {
                buffer[index] += net-&gt;units[y*net-&gt;size+i]*net-&gt;laterals_p[net-&gt;size+(x-i)];
            }
            index++;
        }
    }
    
    index = 0;
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;net-&gt;size; y++) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;net-&gt;size; x++) {
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;net-&gt;size; i++) {
                 buffer1[index] += buffer[i*net-&gt;size+x]*net-&gt;laterals_p[net-&gt;size+(y-i)];
             }
             index++;
         }
     }
     
     memset (buffer, 0, net-&gt;size*net-&gt;size*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
     memset (buffer2, 0, net-&gt;size*net-&gt;size*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
     index = 0;
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;net-&gt;size; y++) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;net-&gt;size; x++) {

             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;net-&gt;size; i++) {
                 buffer[index] += net-&gt;units[y*net-&gt;size+i]*net-&gt;laterals_m[net-&gt;size+(x-i)];
             }
             index++;
         }
     }

     index = 0;
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;net-&gt;size; y++) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x=0; x&lt;net-&gt;size; x++) {
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;net-&gt;size; i++) {
                 buffer2[index] += buffer[i*net-&gt;size+x]*net-&gt;laterals_m[net-&gt;size+(y-i)];
             }
             index++;
         }
     }

     <span class="keywordtype">double</span> x = net-&gt;bubble_x;
     <span class="keywordtype">double</span> y = net-&gt;bubble_y;
     net-&gt;bubble_x = 0;
     net-&gt;bubble_y = 0;
     <span class="keywordtype">double</span> sum = 0;
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;net-&gt;size*net-&gt;size; k++) {
         <span class="keywordtype">int</span> x = rand() % net-&gt;size;
         <span class="keywordtype">int</span> y = rand() % net-&gt;size;

         x = k%net-&gt;size;
         y = k/net-&gt;size;

         index = y*net-&gt;size+x;

         <span class="keywordtype">double</span> u = net-&gt;units[index];
         <span class="keywordtype">double</span> v = net-&gt;afferents[index]*env.units[index] + buffer1[index] - buffer2[index];
         <span class="keywordtype">double</span> dv = (-net-&gt;units[index] + net-&gt;baseline + (1.0f/net-&gt;alpha)*v)*net-&gt;dt;
         net-&gt;units[index] += dv;
         <span class="keywordflow">if</span> (net-&gt;units[index] &gt; 1.0f)      net-&gt;units[index] = 1.0f;
         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (net-&gt;units[index] &lt; 0.0f) net-&gt;units[index] = 0.0f;

         dv = u - net-&gt;units[index];

         sum += net-&gt;units[index];
         net-&gt;bubble_x += net-&gt;units[index] * x/double(net-&gt;size);
         net-&gt;bubble_y += net-&gt;units[index] * y/double(net-&gt;size);

     }

     <span class="keywordflow">if</span> (sum != 0) {
         net-&gt;bubble_x /= sum;
         net-&gt;bubble_y /= sum;
         x = net-&gt;bubble_x;
         y = net-&gt;bubble_y;
     }
 }

<span class="keywordtype">void</span> timeout (<span class="keywordtype">int</span> value) {
    update (&amp;env);
    update (&amp;net);
    scene-&gt;update();
    display ();
    glutTimerFunc (<span class="keywordtype">int</span>(1000.0/50), timeout, 1);
}

<span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    glutInit (&amp;argc, argv);
    glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutCreateWindow (<span class="stringliteral">"CNFT - Full"</span>);
    glutReshapeFunc (reshape);
    glutDisplayFunc (display);
    glutMouseFunc (on_mouse_button);
    glutMotionFunc (on_mouse_move);
    glutKeyboardFunc (on_key_press);
    glutSpecialFunc (on_special_key_press);
    glutReshapeWindow (600,400);
    glutTimerFunc (<span class="keywordtype">int</span>(1000.0/25), timeout, 1);
    
    
    <span class="comment">// Argument parsing</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;argc; i+=2) {
        <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-size"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%d"</span>, &amp;net.size);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-epochs"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%ld"</span>, &amp;net.epochs);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-alpha"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.alpha);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-dt"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.dt);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-baseline"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.baseline);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-af_i"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.af_i);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-gp_i"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.gp_i);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-gp_w"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.gp_w);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-gm_w"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.gm_w);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-gm_i"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;net.gm_i);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-seed"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%d"</span>, &amp;net.seed);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-stim_n"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%d"</span>, &amp;env.stim_n);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-stim_w"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;env.stim_w);
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (argv[i], <span class="stringliteral">"-stim_s"</span>) == 0)
            sscanf (argv[i+1], <span class="stringliteral">"%lf"</span>, &amp;env.stim_s);
    }
    
    
    <span class="comment">// Environment setup</span>
    <span class="comment">// =================</span>
    env.size    = 75;
    env.units      = <span class="keyword">new</span> <span class="keywordtype">double</span>[env.size * env.size];
    env.noise_level = 0.0;
    env.stim_n  = 5;
    env.stim_w  = 0.1f;
    env.stim_s  = 0.00025;
    env.stims   = <span class="keyword">new</span> Stimulus[env.stim_n];
    
    <span class="comment">// Network setup</span>
    <span class="comment">// ==============</span>
    net.size    = env.size;
    net.epochs  = 0;
    net.alpha   = 11.0f;
    net.dt      = 0.1;
    net.baseline= 0.0f;
    net.af_i    = 1.5;
    net.gp_w    = 0.015f;
    net.gp_i    = 1.3f;
    net.gm_w    = 0.8f;
    net.gm_i    = 0.15f;
    net.seed    = 12;
    net.units = <span class="keyword">new</span> <span class="keywordtype">double</span>[net.size * net.size];
    
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;(net.size*net.size); i++)
        net.units[i] = 0;
    net.afferents   = <span class="keyword">new</span> <span class="keywordtype">double</span>[net.size * net.size];
    net.laterals_p  = <span class="keyword">new</span> <span class="keywordtype">double</span>[2*net.size+1];
    net.laterals_m  = <span class="keyword">new</span> <span class="keywordtype">double</span>[2*net.size+1];
    for (<span class="keywordtype">int</span> i=0; i&lt;(2*net.size+1); i++)
        net.laterals_p[i] = sqrt(net.gp_i)*gaussian (0, net.gp_w, (i-net.size)/<span class="keywordtype">double</span>(2*net.size+1));
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;(2*net.size+1); i++)
        net.laterals_m[i] = sqrt(net.gm_i)*gaussian (0, net.gm_w, (i-net.size)/<span class="keywordtype">double</span>(2*net.size+1));
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;net.size*net.size; i++)
        net.afferents[i] = net.af_i;
    
    net.age = 0;
    net.sum_dist  = 0;
    net.sum_dist2 = 0;
    srand (net.seed);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;env.stim_n; i++) {
        env.stims[i].x = env.stim_w/2.0f + (rand()/double(RAND_MAX)) * (1.0f-env.stim_w);
        env.stims[i].y = env.stim_w/2.0f + (rand()/double(RAND_MAX)) * (1.0f-env.stim_w);
        <span class="keywordtype">double</span> theta = (rand()/double(RAND_MAX)) * 2.0f * M_PI;
        env.stims[i].dx = cos(theta) * env.stim_s;
        env.stims[i].dy = sin(theta) * env.stim_s;
    }
    
    <a name="_a7"></a><a class="code" href="classColormap.html" title="A colormap represents a value range using colors.">Colormap</a> *cmap = <a name="a8"></a><a class="code" href="classColormap.html#90712912a1bcd48156a598adc88db676" title="Colormap that goes blue, white, yellow and red.">Colormap::IceAndFire</a>();
    cmap-&gt;<a name="a9"></a><a class="code" href="classColormap.html#b8ca9c6c576749ad2d52e6afaa039c61">scale</a> (-.5,1);
    
    colorbar-&gt;set_cmap (cmap);
    colorbar-&gt;set_gravity (0,-1);
    colorbar-&gt;set_position (0,48,1);
    colorbar-&gt;set_title (<span class="stringliteral">""</span>);
    colorbar-&gt;set_fg_color (0,0,0,1);
    colorbar-&gt;set_br_color (0,0,0,1);
    scene-&gt;add (colorbar);
    
    TextBoxPtr textbox = TextBoxPtr (<span class="keyword">new</span> <a name="_a10"></a><a class="code" href="classTextBox.html" title="TextBox rendering widget.">TextBox</a>());
    textbox-&gt;set_bg_color (1,1,1,.5);
    textbox-&gt;set_fg_color (0,0,0,1);
    textbox-&gt;set_gravity (0,1);
    textbox-&gt;set_position (0,24);
    textbox-&gt;set_justification (0);
    textbox-&gt;set_buffer (<span class="stringliteral">"\033[1mEmergence of Attention within a Neural Population\033[0m\n"</span>
                         <span class="stringliteral">"N.P. Rougier and J. Vitay\n"</span>
                         <span class="stringliteral">"Neural Networks, volume 19, number 5, pp 573-581, June 2006."</span>);
    scene-&gt;add (textbox);
    
    <span class="comment">// Input surface</span>
    SurfacePtr input = SurfacePtr (<span class="keyword">new</span> Surface);
    input-&gt;set_size (.49,.49,.1);
    input-&gt;set_position (-.25, 0);
    input-&gt;set_br_color (0,0,0,1);
    DataPtr input_data = DataPtr (<span class="keyword">new</span> <a name="_a11"></a><a class="code" href="classData.html" title="Encapsulation of raw data.">Data</a>);
    input_data-&gt;set (env.units, env.size, env.size, 1, GL_DOUBLE, <span class="keyword">sizeof</span>(GLdouble));
    input-&gt;set_colormap(cmap);
    input-&gt;set_z_c_data (input_data, input_data);

    <span class="comment">// Focus surface</span>
    SurfacePtr focus = SurfacePtr (<span class="keyword">new</span> Surface);
    focus-&gt;set_size (.49,.49,.1);
    focus-&gt;set_position (.25, 0);
    focus-&gt;set_br_color (0,0,0,1);
    DataPtr focus_data = DataPtr (<span class="keyword">new</span> <a class="code" href="classData.html" title="Encapsulation of raw data.">Data</a>);
    focus_data-&gt;set (net.units, env.size, env.size, 1, GL_DOUBLE, <span class="keyword">sizeof</span>(GLdouble));
    focus-&gt;set_colormap(cmap);
    focus-&gt;set_z_c_data (focus_data,focus_data);

    scene-&gt;add (input);
    scene-&gt;add (focus);
    scene-&gt;set_orientation (45, 0);
    scene-&gt;set_bg_color (1, 1, 1, 1);
    scene-&gt;set_zoom (5);
    update(&amp;env);
    update(&amp;net);
    
    glutMainLoop();
    <span class="keywordflow">return</span> 0;
}

</pre></div> </div>
</body>
</html>
